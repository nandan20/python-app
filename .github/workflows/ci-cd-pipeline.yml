name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build and Push Docker Image
        run: |
          docker build -t ${{ secrets.DOCKER_USERNAME }}/my-app:latest .
          docker tag ${{ secrets.DOCKER_USERNAME }}/my-app:latest ${{ secrets.DOCKER_USERNAME }}/my-app:${{ github.sha }}
          
          # Push only for main branch commits
          if [ "$GITHUB_REF" == "refs/heads/main" ]; then
            docker push ${{ secrets.DOCKER_USERNAME }}/my-app:latest
            docker push ${{ secrets.DOCKER_USERNAME }}/my-app:${{ github.sha }}
          fi

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Update K8s Manifest
        run: |
          sed -i "s|image: .*/my-app:.*|image: ${{ secrets.DOCKER_USERNAME }}/my-app:${{ github.sha }}|" k8s/deployment.yaml

      - name: Sync Git Changes
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # Pull remote changes safely
          git pull origin main --rebase --autostash
          
          # Commit only if changes exist
          if ! git diff --quiet k8s/deployment.yaml; then
            git add k8s/deployment.yaml
            git commit -m "Update image to ${{ github.sha }}"
            git push origin main --force-with-lease
          else
            echo "No changes to deployment.yaml"
          fi

      - name: Prepare SSH Key
        run: |
          # Convert SSH key to UNIX format
          echo "${{ secrets.SSH_PRIVATE_KEY }}" | tr -d '\r' > my-ec2-key
          chmod 600 my-ec2-key

      - name: ArgoCD Deployment
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ubuntu
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}  # Should be https://host:port
          ARGOCD_USER: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASS: ${{ secrets.ARGOCD_PASSWORD }}
        run: |
          ssh -i my-ec2-key -T -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST << EOSSH
          #!/bin/bash

          # Validate environment variables
          echo "ARGOCD_SERVER: ${ARGOCD_SERVER:?ERROR: ARGOCD_SERVER env var not set}"

          # Verify network connectivity
          echo "Testing connection to ArgoCD server..."
          if ! curl -k -I --connect-timeout 5 "\$ARGOCD_SERVER"; then
            echo "ERROR: Cannot reach ArgoCD server at \$ARGOCD_SERVER"
            exit 1
          fi

          # Install ArgoCD CLI if missing
          if ! command -v argocd >/dev/null; then
            curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
            chmod +x argocd
            sudo mv argocd /usr/local/bin/
          fi

          # Login with force-confirm and web transport
          argocd login "\$ARGOCD_SERVER" \\
            --username="\$ARGOCD_USER" \\
            --password="\$ARGOCD_PASS" \\
            --insecure \\
            --grpc-web

          # Force sync application with timeout
          echo "Starting sync operation..."
          argocd app sync my-app \\
            --force \\
            --timeout 300 \\
            --retry-limit 5

          # Verify sync status
          argocd app wait my-app --health
          EOSSH
